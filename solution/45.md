# Problem
[Link](https://leetcode-cn.com/problems/jump-game-ii/)

# Solution
## DP
## 线段树
* 从后往前更新节点，更新节点 i 的时候，相当于从 i + 1->i + nums[i]的区间内选取最小值 + 1。
单点改，区间查，经典线段树。
* 时间复杂度O(nlogn)

# Code
```cpp
```
```cpp
class Solution {
public:

    #define lson (root << 1)
    #define rson ((root << 1) | 1)

    std::vector<int> tree;
    
    void Update(int root, int L,int R, int pos, int val) {
        if (L == R) {
            tree[root] = val;
            return ;
        }
        int mid = (L + R) >> 1;
        if (pos <= mid)
            Update(lson, L, mid, pos, val);
        else
            Update(rson, mid + 1, R, pos, val);

        tree[root] = std::min(tree[lson], tree[rson]);
        return ;
    }

    int Query(int root,int L, int R, int ql, int qr) {
        if (ql <= L && qr >= R) {
            return tree[root];
        }
        int mid = (L + R) >> 1;
        if (qr <= mid) 
            return Query(lson, L, mid, ql, qr);
        if (ql > mid) 
            return Query(rson, mid + 1, R, ql, qr);
        int lans = Query(lson, L, mid, ql, mid);
        int rans = Query(rson, mid + 1, R, mid + 1, qr);
        return std::min(lans, rans);
    }

    int jump(vector<int>& nums) {
        if (nums.size() <= 1) return 0;
        tree.assign(nums.size() * 4, 0);
        Update(1, 0, nums.size() - 1, nums.size() - 1, 0);

        for (int i = nums.size() - 2; i >= 0; --i) {
            int ql = i + 1;
            int qr = std::min(i + nums[i], static_cast<int>(nums.size() - 1));
            if (qr < ql) {
                Update(1, 0, nums.size() - 1, i,nums.size());
                continue;
            }
            
            int min_step = Query(1, 0, nums.size() - 1, ql, qr);
            if (i == 0) {
                return min_step + 1;
            }
            Update(1, 0, nums.size() - 1, i, min_step + 1);
        }

        return Query(1, 0, nums.size() - 1, 0, 0);
    }
};
```